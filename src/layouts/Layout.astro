---
import "../styles/global.css";
import animationsCssUrl from "../styles/animations.css?url";
import Navbar from "../components/Navbar.astro";
import Footer from "../components/Footer.astro";

export interface Props {
  title?: string;
  description?: string;
  image?: string;
}

const { 
  title = "Tecnomata | SEO Local y Páginas Web",
  description = "Agencia SEO en Morelos. Posicionamos negocios locales en Google Maps y creamos páginas web que venden. SEO local, diseño web y reputación online.",
  image = "/favicon.svg"
} = Astro.props;
---

<html lang="es">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>{title}</title>
    <meta name="description" content={description} />
    <meta name="author" content="Tecnómata" />
    <meta name="robots" content="index, follow" />
    
    <!-- Activar la clase 'js' en <html> lo antes posible para evitar parpadeos -->
    <script is:inline>
      document.documentElement.classList.add('js');
    </script>
    <!-- Inyectar override temporal para que NADA se oculte antes de inicializar animaciones -->
    <script is:inline>
      (function(){
        try {
          var s = document.createElement('style');
          s.id = 'pre-js-style';
          s.textContent = '.scroll-animate, .animate-fade-in-up, .animate-slide-in-left, .animate-slide-in-right, .animate-scale-in, .animate-bounce-in{opacity:1!important;transform:none!important;animation:none!important}';
          document.head.appendChild(s);
        } catch(e){}
      })();
    </script>
  
    <!-- Preconnect for performance -->
    <link rel="preconnect" href="https://tecnomata.com" />
    <link rel="dns-prefetch" href="https://tecnomata.com" />
    
  <!-- Nota: evitamos preloads de fuentes variables para no generar warnings si el uso se difiere; usamos font-display: swap en @font-face -->
    
    <!-- Critical inline CSS for fonts (evita FOUT) -->
    <style>
      @font-face {
        font-family: 'Inter';
        font-style: normal;
        font-weight: 100 900;
        font-display: optional;
        src: url('/fonts/Inter/Inter-VariableFont_opsz,wght.ttf') format('truetype');
      }
      @font-face {
        font-family: 'DM Sans';
        font-style: normal;
        font-weight: 100 1000;
        font-display: optional;
        src: url('/fonts/DM_Sans/DMSans-VariableFont_opsz,wght.ttf') format('truetype');
      }
      
      /* Critical CSS for Hero H1 - MUST load instantly */
      body { 
        margin: 0; 
        background: #fff;
        font-family: Inter, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
        /* Evitar shifts por mobile menu */
        overflow-x: hidden;
      }
      .bg-white { background-color: #ffffff; }
      .text-center { text-align: center; }
      .font-black { font-weight: 900; }
      .text-gray-900 { color: #111827; }
      .leading-tight { line-height: 1.25; }
      .tracking-tighter { letter-spacing: -0.05em; }
      .text-primary { color: #2563eb; }
      .mx-auto { margin-left: auto; margin-right: auto; }
      .max-w-7xl { max-width: 80rem; }
      .px-6 { padding-left: 1.5rem; padding-right: 1.5rem; }
      .py-24 { padding-top: 6rem; padding-bottom: 6rem; }
      .mt-6 { margin-top: 1.5rem; }
      .max-w-3xl { max-width: 48rem; }
      .text-lg { font-size: 1.125rem; line-height: 1.75rem; }
      .text-gray-600 { color: #4b5563; }
      @media (min-width: 768px) {
        .md\:text-7xl { font-size: 4.5rem; line-height: 1; }
        .md\:text-xl { font-size: 1.25rem; line-height: 1.75rem; }
      }
      @media (min-width: 1024px) {
        .lg\:text-8xl { font-size: 6rem; line-height: 1; }
        .lg\:py-32 { padding-top: 8rem; padding-bottom: 8rem; }
      }
    </style>
    
    <!-- Mientras no exista la clase .js en <html>, nunca ocultar secciones -->
    <style id="pre-js-visibility">
      html:not(.js) .scroll-animate,
      html:not(.js) .animate-fade-in-up,
      html:not(.js) .animate-slide-in-left,
      html:not(.js) .animate-slide-in-right,
      html:not(.js) .animate-scale-in,
      html:not(.js) .animate-bounce-in {
        opacity: 1 !important;
        transform: none !important;
        animation: none !important;
      }
    </style>
    
  <!-- Load animations CSS async (no bloquea renderizado) -->
  <link rel="preload" href={animationsCssUrl} as="style" onload="this.onload=null;this.rel='stylesheet'" />
  <noscript><link rel="stylesheet" href={animationsCssUrl} /></noscript>
  
  <!-- Site Favicon -->
  <link rel="icon" type="image/svg+xml" href="/favicon.svg" />
  <link rel="shortcut icon" type="image/svg+xml" href="/favicon.svg" />
  <!-- Multiple sizes for better compatibility -->
  <link rel="apple-touch-icon" href="/favicon.svg" />
    
    <!-- Open Graph -->
    <meta property="og:title" content={title} />
    <meta property="og:description" content={description} />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://tecnomata.com/" />
    <meta property="og:image" content={image} />
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary" />
    <meta name="twitter:title" content={title} />
    <meta name="twitter:description" content={description} />
    <meta name="twitter:image" content={image} />
    
    <!-- Local fonts loaded via CSS imports -->
    
    <!-- Sistema centralizado de colores ya integrado en global.css -->
    
    <!-- Si no hay JS, aseguramos que el contenido no quede oculto -->
    <noscript>
      <style>
        .scroll-animate { opacity: 1 !important; transform: none !important; animation: none !important; }
      </style>
    </noscript>
  </head>
  <body class="bg-white text-gray-900">
    <Navbar />
    <slot />
    <Footer />
    
    <!-- Sistema de animaciones inline (NO TOCAR - código optimizado y probado) -->
    <script is:inline>
class VisinexAnimations {
  constructor() {
    this.reducedMode = false;
    this.init();
  }

  init() {
    if (typeof window === 'undefined') return;

    const prefersReduced = window.matchMedia && window.matchMedia('(prefers-reduced-motion: reduce)').matches;
    const isMobile = (window.matchMedia && window.matchMedia('(max-width: 768px)').matches) || window.innerWidth < 769;
    this.reducedMode = !!(prefersReduced || isMobile);

    const initAnimations = () => {
      this.setupScrollAnimations();
      this.setupScrollBars(); // IMPORTANTE: barras con lógica random
      
      if (!this.reducedMode) {
        this.setupCounters();
        this.setupParallax();
      }

      // Quitar override temporal
      setTimeout(() => {
        const preJsStyle = document.getElementById('pre-js-style');
        if (preJsStyle && preJsStyle.parentNode) {
          preJsStyle.parentNode.removeChild(preJsStyle);
        }
      }, 400);
    };

    const delayInit = () => {
      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', initAnimations, { once: true });
      } else {
        initAnimations();
      }
    };

    if ('requestIdleCallback' in window) {
      window.requestIdleCallback(() => delayInit(), { timeout: 800 });
    } else {
      setTimeout(delayInit, 120);
    }
  }

  setupScrollAnimations() {
    if (this.reducedMode) {
      document.querySelectorAll('.scroll-animate, [data-animate]').forEach((el) => {
        el.classList.add('in-view');
      });
      return;
    }

    const observer = new IntersectionObserver((entries) => {
      entries.forEach(entry => {
        const el = entry.target;
        const once = el.dataset.once === 'true';

        if (entry.isIntersecting) {
          el.classList.add('in-view');
          
          const animType = el.dataset.animate;
          if (animType) {
            const animMap = {
              'fade-up': 'animate-fade-in-up',
              'slide-left': 'animate-slide-in-left',
              'slide-right': 'animate-slide-in-right',
              'scale-in': 'animate-scale-in',
              'bounce-in': 'animate-bounce-in'
            };
            const animClass = animMap[animType] || 'animate-fade-in-up';
            const delay = el.dataset.delay;
            
            if (delay) {
              setTimeout(() => { el.classList.add(animClass); }, parseInt(delay, 10));
            } else {
              el.classList.add(animClass);
            }
          }

          if (el.classList.contains('counter')) {
            this.animateCounter(el);
          }

          if (once) observer.unobserve(el);
        } else if (!once && entry.boundingClientRect.top > 0) {
          const animType = el.dataset.animate;
          if (animType) {
            const animMap = {
              'fade-up': 'animate-fade-in-up',
              'slide-left': 'animate-slide-in-left',
              'slide-right': 'animate-slide-in-right',
              'scale-in': 'animate-scale-in',
              'bounce-in': 'animate-bounce-in'
            };
            el.classList.remove(animMap[animType] || 'animate-fade-in-up');
          }
          el.classList.remove('in-view');
        }
      });
    }, { threshold: 0.1, rootMargin: '50px 0px' });

    document.querySelectorAll('.scroll-animate, [data-animate]').forEach(el => {
      if (!el.classList.contains('scroll-animate')) {
        el.classList.add('scroll-animate');
      }
      observer.observe(el);
    });

    document.querySelectorAll('.counter').forEach(c => {
      observer.observe(c);
    });
  }

  animateCounter(el) {
    if (el.dataset.animated === 'true') return;
    el.dataset.animated = 'true';

    const target = parseInt(el.dataset.target || '0');
    const suffix = el.dataset.suffix || '';
    const prefix = el.dataset.prefix || '';
    const duration = parseInt(el.dataset.duration || '2000');

    if (target === 0) return;

    const startTime = performance.now();
    const animate = (currentTime) => {
      const elapsed = currentTime - startTime;
      const progress = Math.min(elapsed / duration, 1);
      const easeOut = 1 - Math.pow(1 - progress, 4);
      const current = Math.floor(target * easeOut);
      
      el.textContent = prefix + current + suffix;
      
      if (progress < 1) {
        requestAnimationFrame(animate);
      } else {
        el.textContent = prefix + target + suffix;
      }
    };
    
    requestAnimationFrame(animate);
  }

  setupCounters() {
    setTimeout(() => {
      const counters = document.querySelectorAll('.counter:not([data-animated="true"])');
      if (counters.length === 0) return;

      const viewportHeight = window.innerHeight;
      counters.forEach(counter => {
        const rect = counter.getBoundingClientRect();
        if (rect.top < viewportHeight && rect.bottom > 0) {
          this.animateCounter(counter);
        }
      });
    }, 1000);
  }

  setupParallax() {
    const heroElements = document.querySelectorAll('.parallax-hero');
    if (heroElements.length === 0) return;

    window.addEventListener('scroll', () => {
      const scrollPos = window.pageYOffset;
      heroElements.forEach(hero => {
        if (scrollPos < window.innerHeight) {
          hero.style.transform = `translateY(${scrollPos * 0.5}px)`;
        }
      });
    });
  }

  setupScrollBars() {
    const scrollBars = document.querySelectorAll('[data-scroll-bar]');
    if (scrollBars.length === 0) return;

    // Asignar direcciones random a cada barra
    const randomDirections = ['left-right', 'right-left', 'center'];
    scrollBars.forEach((bar) => {
      if (!bar.dataset.scrollDirection || bar.dataset.scrollDirection === 'random') {
        const randomDir = randomDirections[Math.floor(Math.random() * randomDirections.length)];
        bar.dataset.scrollDirection = randomDir;
        bar.dataset.scrollOffset = Math.random() * 0.15;
      }
    });

    const updateScrollBars = () => {
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const documentHeight = document.documentElement.scrollHeight;
      const viewportHeight = window.innerHeight;
      const windowHeight = window.innerHeight;
      const windowWidth = window.innerWidth;
      const fillStartZone = windowHeight * 0.8;
      const fillEndZone = windowHeight * 0.3;
      const totalDistance = fillStartZone - fillEndZone;

      const barData = Array.from(scrollBars).map(container => {
        const rect = container.getBoundingClientRect();
        const elementTop = rect.top;

        let progress;
        if (elementTop >= fillStartZone) {
          progress = 0;
        } else if (elementTop <= fillEndZone) {
          progress = 1;
        } else {
          const currentDistance = fillStartZone - elementTop;
          progress = currentDistance / totalDistance;
        }

        return {
          container,
          progress,
          direction: container.dataset.scrollDirection || 'left-right',
          colorBar: container.querySelector('.scroll-color-fill')
        };
      });

      barData.forEach(({container, progress, direction, colorBar}) => {
        if (!colorBar) return;

        switch (direction) {
          case 'left-right':
            colorBar.style.width = `${progress * 100}%`;
            colorBar.style.transformOrigin = 'left';
            colorBar.style.transform = 'scaleX(1)';
            break;
          case 'right-left':
            colorBar.style.width = `${progress * 100}%`;
            colorBar.style.transformOrigin = 'right';
            colorBar.style.transform = 'scaleX(1)';
            colorBar.style.marginLeft = `${(1 - progress) * 100}%`;
            break;
          case 'center':
            colorBar.style.width = `${progress * 100}%`;
            colorBar.style.transformOrigin = 'center';
            colorBar.style.transform = 'scaleX(1)';
            colorBar.style.marginLeft = `${((1 - progress) / 2) * 100}%`;
            break;
          default:
            colorBar.style.width = `${progress * 100}%`;
        }

        colorBar.style.transition = 'all 0.2s ease-out';
      });
    };

    let ticking = false;
    const handleScroll = () => {
      if (!ticking) {
        requestAnimationFrame(() => {
          updateScrollBars();
          ticking = false;
        });
        ticking = true;
      }
    };

    window.addEventListener('scroll', handleScroll, { passive: true });
    updateScrollBars();
  }
}

const visinexAnim = new VisinexAnimations();
window.VisinexAnimations = VisinexAnimations;
    </script>
  </body>
</html>
